fs: namespace == std::filesystem;

ensure_dir: (dir: fs::path) = {
	status := fs::status(dir);

	if status.type() == fs::file_type::not_found {
		fs::create_directories(dir);
	}
}


find_closest_file: (filename) find_closest_file(filename, fs::current_path());
find_closest_file: (filename, base: fs::path) -> std::optional<fs::path> = {
	if fs::exists(base / filename) {
		return base / filename;
	}

	if !base.has_parent_path() || base.parent_path() == base {
		return std::nullopt;
	}

	return find_closest_file(filename, base.parent_path());
}

expect: <T>(move opt: std::optional<T>, message) -> T = {
	if !opt {
		std::println("ERROR: {}", message);
		std::abort();
	}

	return opt*;
}

main: (args) -> int = {
	cpp2b_config_file := find_closest_file("cpp2b.toml").expect("Cannot find cpp2b config file. Are you sure you're running cpp2b in a cpp2b project?");

	std::println("Found cpp2b config file: {}", cpp2b_config_file.string());

	fs::current_path(cpp2b_config_file.parent_path());

	ensure_dir(".cache/modules");
	ensure_dir(".cache/repos");
	ensure_dir(".cache/tools");

	for args do (arg) {
		std::println("arg={}", arg);
	}

	return 0;
}
